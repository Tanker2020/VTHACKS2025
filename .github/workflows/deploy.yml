name: CI/CD (GHCR + self-hosted deploy w/ rollback)

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/railsApp/**'
      - 'backend/python/**'
      - 'backend/deploy/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to deploy (prod | prev | <sha>)'
        required: true
        default: 'prod'

concurrency:
  group: deploy-main
  cancel-in-progress: true

env:
  RAILS_DIR: backend/railsApp
  PY_DIR: backend/python
  COMPOSE_DIR: backend/deploy

jobs:
  build-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_ns: ${{ steps.compute.outputs.image_ns }}
    steps:
      - uses: actions/checkout@v4

      - name: Compute IMAGE_NS (lowercased)
        id: compute
        shell: bash
        run: |
          ns="ghcr.io/${GITHUB_REPOSITORY,,}"
          echo "IMAGE_NS=${ns}" >> $GITHUB_ENV
          echo "image_ns=${ns}" >> $GITHUB_OUTPUT

      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Build & push Rails (arm64)
      - name: Build & push Rails (arm64)
        run: |
          docker buildx build \
            --platform linux/arm64 \
            --pull \
            --cache-from type=registry,ref=$IMAGE_NS/rails:buildcache \
            --cache-to   type=registry,ref=$IMAGE_NS/rails:buildcache,mode=max \
            -t $IMAGE_NS/rails:${{ github.sha }} \
            -f $RAILS_DIR/Dockerfile \
            $RAILS_DIR \
            --push

      # Build & push Python Agent (arm64)
      - name: Build & push Agent (arm64)
        run: |
          docker buildx build \
            --platform linux/arm64 \
            --pull \
            --cache-from type=registry,ref=$IMAGE_NS/agent:buildcache \
            --cache-to   type=registry,ref=$IMAGE_NS/agent:buildcache,mode=max \
            -t $IMAGE_NS/agent:${{ github.sha }} \
            -f $PY_DIR/Dockerfile \
            $PY_DIR \
            --push
  deploy:
    needs: build-push
    runs-on: self-hosted
    permissions:
      contents: read
      packages: write
    env:
      BUILD_TAG: ${{ github.sha }} # <-- always the fresh image
      DEPLOY_TAG: prod
      IMAGE_NS: ${{ needs.build-push.outputs.image_ns }}
    steps:
      - uses: actions/checkout@v4

      - name: Login to GHCR on VM
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      # --- Rotate/prod-prev on the VM (arm64) ---
      - name: Promote rails sha -> prod (and rotate)
        run: |
          set -euxo pipefail
          echo "IMAGE_NS=$IMAGE_NS  BUILD_TAG=$BUILD_TAG"
          # Pull the freshly built sha (arm64)
          docker pull "$IMAGE_NS/rails:${BUILD_TAG}"
          # If prod exists, move it to prev
          if docker pull "$IMAGE_NS/rails:prod" >/dev/null 2>&1; then
            docker tag  "$IMAGE_NS/rails:prod" "$IMAGE_NS/rails:prev"
            docker push "$IMAGE_NS/rails:prev" || true
          fi
          # Tag sha -> prod and push
          docker tag  "$IMAGE_NS/rails:${BUILD_TAG}" "$IMAGE_NS/rails:prod"
          docker push "$IMAGE_NS/rails:prod"

      - name: Promote agent sha -> prod (and rotate)
        run: |
          set -euxo pipefail
          docker pull "$IMAGE_NS/agent:${BUILD_TAG}"
          if docker pull "$IMAGE_NS/agent:prod" >/dev/null 2>&1; then
            docker tag  "$IMAGE_NS/agent:prod" "$IMAGE_NS/agent:prev"
            docker push "$IMAGE_NS/agent:prev" || true
          fi
          docker tag  "$IMAGE_NS/agent:${BUILD_TAG}" "$IMAGE_NS/agent:prod"
          docker push "$IMAGE_NS/agent:prod"

      # --- Deploy with compose (use prod tag by default) ---
      - name: Pull images for compose (prod)
        working-directory: deploy
        run: IMAGE_NS="$IMAGE_NS" TAG="$DEPLOY_TAG" docker compose pull

      - name: DB migrate (rails)
        working-directory: deploy
        env:
          RAILS_ENV: production
        run: |
          # Only run migrations if DATABASE_URL exists inside the rails container
          if IMAGE_NS=${IMAGE_NS} TAG=${DEPLOY_TAG} docker compose run --rm rails sh -lc 'test -n "$DATABASE_URL"'; then
            IMAGE_NS=${IMAGE_NS} TAG=${DEPLOY_TAG} docker compose run --rm rails bundle exec rake db:migrate
          else
            echo "DATABASE_URL not set; skipping db:migrate"
          fi

      - name: Up services
        working-directory: deploy
        run: IMAGE_NS="$IMAGE_NS" TAG="$DEPLOY_TAG" docker compose up -d

      - name: Health check
        run: |
          set -euxo pipefail
          curl -fsS http://127.0.0.1:3000/up || (docker ps; docker logs $(docker ps -q --filter name=_rails_ | head -1); exit 1)